#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Lib

#include "Basic.hpp"

#include "Lib_classes.hpp"
#include "Lib_parameters.hpp"


namespace SDK
{

// Function lib.lib_C.physSound
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPhysicalMaterial*                PhysMat                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FStruct_physSound                Data                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::PhysSound(class UPhysicalMaterial* PhysMat, class UObject* __WorldContext, bool* Return, struct FStruct_physSound* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "physSound");

	Params::Lib_C_PhysSound Parms{};

	Parms.PhysMat = PhysMat;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);
}


// Function lib.lib_C.getMainGamemode
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AMainGamemode_C*                  AsMain_Gamemode                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetMainGamemode(class UObject* __WorldContext, class AMainGamemode_C** AsMain_Gamemode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getMainGamemode");

	Params::Lib_C_GetMainGamemode Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AsMain_Gamemode != nullptr)
		*AsMain_Gamemode = Parms.AsMain_Gamemode;
}


// Function lib.lib_C.getMainPlayer
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AMainPlayer_C*                    AsMain_Player                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetMainPlayer(class UObject* __WorldContext, class AMainPlayer_C** AsMain_Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getMainPlayer");

	Params::Lib_C_GetMainPlayer Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AsMain_Player != nullptr)
		*AsMain_Player = Parms.AsMain_Player;
}


// Function lib.lib_C.setSettings_d
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::SetSettings_d(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "setSettings_d");

	Params::Lib_C_SetSettings_d Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.4dir
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          In                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::Fourdir(const struct FVector& In, class UObject* __WorldContext, struct FVector* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "4dir");

	Params::Lib_C_Fourdir Parms{};

	Parms.In = std::move(In);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);
}


// Function lib.lib_C.getSatelliteName
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           TechName                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FText                             Normal                                                 (Parm, OutParm)
// class FText                             Classic                                                (Parm, OutParm)

void ULib_C::GetSatelliteName(int32 Param_Index, class UObject* __WorldContext, class FString* TechName, class FText* Normal, class FText* Classic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getSatelliteName");

	Params::Lib_C_GetSatelliteName Parms{};

	Parms.Param_Index = Param_Index;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (TechName != nullptr)
		*TechName = std::move(Parms.TechName);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);

	if (Classic != nullptr)
		*Classic = std::move(Parms.Classic);
}


// Function lib.lib_C.randObject_all
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::RandObject_all(class UObject* __WorldContext, class FName* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "randObject_all");

	Params::Lib_C_RandObject_all Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function lib.lib_C.getNRT
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                       Key                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UConstantQNRT*                    NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetNRT(const class USoundBase*& Key, class UObject* __WorldContext, class UConstantQNRT** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getNRT");

	Params::Lib_C_GetNRT Parms{};

	Parms.Key = Key;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function lib.lib_C.setButtonOffset
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Z                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::SetButtonOffset(class USceneComponent* Comp, float Z, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "setButtonOffset");

	Params::Lib_C_SetButtonOffset Parms{};

	Parms.Comp = Comp;
	Parms.Z = Z;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.AddPoints
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Add                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::AddPoints(int32 Add, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "AddPoints");

	Params::Lib_C_AddPoints Parms{};

	Parms.Add = Add;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.getPoints
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Points                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetPoints(class UObject* __WorldContext, int32* Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getPoints");

	Params::Lib_C_GetPoints Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Points != nullptr)
		*Points = Parms.Points;
}


// Function lib.lib_C.countServerEff
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AServerBox_C*>             Servers                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Eff                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::CountServerEff(TArray<class AServerBox_C*>& Servers, int32 Type, class UObject* __WorldContext, float* Eff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "countServerEff");

	Params::Lib_C_CountServerEff Parms{};

	Parms.Servers = std::move(Servers);
	Parms.Type = Type;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Servers = std::move(Parms.Servers);

	if (Eff != nullptr)
		*Eff = Parms.Eff;
}


// Function lib.lib_C.getServerTypes
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AServerBox_C*>             Servers                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AServerBox_C*>             Eff                                                    (Parm, OutParm)

void ULib_C::GetServerTypes(TArray<class AServerBox_C*>& Servers, int32 Type, class UObject* __WorldContext, TArray<class AServerBox_C*>* Eff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getServerTypes");

	Params::Lib_C_GetServerTypes Parms{};

	Parms.Servers = std::move(Servers);
	Parms.Type = Type;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Servers = std::move(Parms.Servers);

	if (Eff != nullptr)
		*Eff = std::move(Parms.Eff);
}


// Function lib.lib_C.randObject_acc
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::RandObject_acc(class UObject* __WorldContext, class FName* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "randObject_acc");

	Params::Lib_C_RandObject_acc Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function lib.lib_C.weightedRandom
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>                           Weights                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::WeightedRandom(TArray<float>& Weights, class UObject* __WorldContext, int32* Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "weightedRandom");

	Params::Lib_C_WeightedRandom Parms{};

	Parms.Weights = std::move(Weights);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Weights = std::move(Parms.Weights);

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function lib.lib_C.getWeightedObject
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Output                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetWeightedObject(class UObject* __WorldContext, class FName* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getWeightedObject");

	Params::Lib_C_GetWeightedObject Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function lib.lib_C.findNRT
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                       Key                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftObjectPtr<class UObject>           Soft                                                   (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::FindNRT(const class USoundBase*& Key, class UObject* __WorldContext, TSoftObjectPtr<class UObject>* Soft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "findNRT");

	Params::Lib_C_FindNRT Parms{};

	Parms.Key = Key;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Soft != nullptr)
		*Soft = Parms.Soft;
}


// Function lib.lib_C.getMainGameInstance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UGameInst_C*                      AsGame_Inst                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetMainGameInstance(class UObject* __WorldContext, class UGameInst_C** AsGame_Inst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getMainGameInstance");

	Params::Lib_C_GetMainGameInstance Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AsGame_Inst != nullptr)
		*AsGame_Inst = Parms.AsGame_Inst;
}


// Function lib.lib_C.setButtonRot
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Z                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::SetButtonRot(class USceneComponent* Comp, float Z, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "setButtonRot");

	Params::Lib_C_SetButtonRot Parms{};

	Parms.Comp = Comp;
	Parms.Z = Z;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.setSignalID
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_signalDataDynamic        Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_signalDataDynamic        OutputPin                                              (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::SetSignalID(struct FStruct_signalDataDynamic& Data, class UObject* __WorldContext, struct FStruct_signalDataDynamic* OutputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "setSignalID");

	Params::Lib_C_SetSignalID Parms{};

	Parms.Data = std::move(Data);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Data = std::move(Parms.Data);

	if (OutputPin != nullptr)
		*OutputPin = std::move(Parms.OutputPin);
}


// Function lib.lib_C.SetSettings
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::SetSettings(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "SetSettings");

	Params::Lib_C_SetSettings Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.runSubtitle
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             RowName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent*                  AudioComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CustomTime                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::RunSubtitle(class FName RowName, class UAudioComponent* AudioComponent, bool CustomTime, float Speed, float Time, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "runSubtitle");

	Params::Lib_C_RunSubtitle Parms{};

	Parms.RowName = RowName;
	Parms.AudioComponent = AudioComponent;
	Parms.CustomTime = CustomTime;
	Parms.Speed = Speed;
	Parms.Time = Time;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.addHint
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (BlueprintVisible, BlueprintReadOnly, Parm)
// Enum_notifyType                         Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::AddHint(const class FText& InText, Enum_notifyType Type, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "addHint");

	Params::Lib_C_AddHint Parms{};

	Parms.InText = std::move(InText);
	Parms.Type = Type;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.isBuoyant 
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    buoyant_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsBuoyant_(class AActor* Actor, class UObject* __WorldContext, bool* buoyant_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isBuoyant ");

	Params::Lib_C_IsBuoyant_ Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (buoyant_ != nullptr)
		*buoyant_ = Parms.buoyant_;
}


// Function lib.lib_C.addEmail
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Item_Pfp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// Enum_emailChars                         Item_Username1                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             Item_Topic                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// class FText                             Item_Text                                              (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::AddEmail(class UTexture2D* Item_Pfp, Enum_emailChars Item_Username1, const class FText& Item_Topic, const class FText& Item_Text, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "addEmail");

	Params::Lib_C_AddEmail Parms{};

	Parms.Item_Pfp = Item_Pfp;
	Parms.Item_Username1 = Item_Username1;
	Parms.Item_Topic = std::move(Item_Topic);
	Parms.Item_Text = std::move(Item_Text);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.add_task
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_task                     Task                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class FText                             Suff                                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::Add_task(const struct FStruct_task& Task, const class FText& Suff, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "add_task");

	Params::Lib_C_Add_task Parms{};

	Parms.Task = std::move(Task);
	Parms.Suff = std::move(Suff);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.isDreaming
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dreaming                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsDreaming(class UObject* __WorldContext, bool* Dreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isDreaming");

	Params::Lib_C_IsDreaming Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Dreaming != nullptr)
		*Dreaming = Parms.Dreaming;
}


// Function lib.lib_C.savToObj
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FStruct_save                     Sav                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_object                   Obj                                                    (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::SavToObj(const struct FStruct_save& Sav, class UObject* __WorldContext, struct FStruct_object* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "savToObj");

	Params::Lib_C_SavToObj Parms{};

	Parms.Sav = std::move(Sav);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Obj != nullptr)
		*Obj = std::move(Parms.Obj);
}


// Function lib.lib_C.objToSav
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FStruct_object                   Sav                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_save                     Obj                                                    (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::ObjToSav(const struct FStruct_object& Sav, class UObject* __WorldContext, struct FStruct_save* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "objToSav");

	Params::Lib_C_ObjToSav Parms{};

	Parms.Sav = std::move(Sav);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Obj != nullptr)
		*Obj = std::move(Parms.Obj);
}


// Function lib.lib_C.progressAchievement
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Achievement                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Popup                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Autosave                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::ProgressAchievement(const class FName Achievement, bool Popup, bool Autosave, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "progressAchievement");

	Params::Lib_C_ProgressAchievement Parms{};

	Parms.Achievement = Achievement;
	Parms.Popup = Popup;
	Parms.Autosave = Autosave;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.progressAdvancement
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Advancement                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DisablePopup                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Finished                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FName                             Param_Name                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::ProgressAdvancement(const class FName Advancement, bool DisablePopup, class UObject* __WorldContext, bool* Finished, class FName* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "progressAdvancement");

	Params::Lib_C_ProgressAdvancement Parms{};

	Parms.Advancement = Advancement;
	Parms.DisablePopup = DisablePopup;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Finished != nullptr)
		*Finished = Parms.Finished;

	if (Param_Name != nullptr)
		*Param_Name = Parms.Param_Name;
}


// Function lib.lib_C.nameLocText
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_action                             Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Strng                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ULib_C::NameLocText(Enum_action Action, class UObject* __WorldContext, class FString* Strng)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "nameLocText");

	Params::Lib_C_NameLocText Parms{};

	Parms.Action = Action;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Strng != nullptr)
		*Strng = std::move(Parms.Strng);
}


// Function lib.lib_C.buttonLoc
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Tag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Return                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ULib_C::buttonLoc(class FName Tag, class UObject* __WorldContext, class FString* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "buttonLoc");

	Params::Lib_C_buttonLoc Parms{};

	Parms.Tag = Tag;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);

	return Parms.ReturnValue;
}


// Function lib.lib_C.hasAchievement
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Achievement                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ULib_C::HasAchievement(class FName Achievement, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "hasAchievement");

	Params::Lib_C_HasAchievement Parms{};

	Parms.Achievement = Achievement;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function lib.lib_C.getResponse
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_signalResponse                     Response                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Special                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             Topic                                                  (Parm, OutParm)
// class FText                             Desc                                                   (Parm, OutParm)
// Enum_emailChars                         Character                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture2D*                       Avatar                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetResponse(Enum_signalResponse Response, const class FString& Special, class UObject* __WorldContext, class FText* Topic, class FText* Desc, Enum_emailChars* Character, class UTexture2D** Avatar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getResponse");

	Params::Lib_C_GetResponse Parms{};

	Parms.Response = Response;
	Parms.Special = std::move(Special);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Topic != nullptr)
		*Topic = std::move(Parms.Topic);

	if (Desc != nullptr)
		*Desc = std::move(Parms.Desc);

	if (Character != nullptr)
		*Character = Parms.Character;

	if (Avatar != nullptr)
		*Avatar = Parms.Avatar;
}


// Function lib.lib_C.getResponsePriority
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_signalResponse                     Response                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Priority                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetResponsePriority(Enum_signalResponse Response, class UObject* __WorldContext, int32* Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getResponsePriority");

	Params::Lib_C_GetResponsePriority Parms{};

	Parms.Response = Response;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Priority != nullptr)
		*Priority = Parms.Priority;
}


// Function lib.lib_C.getCarpet
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UMaterialInterface* ULib_C::GetCarpet(int32 Param_Index, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getCarpet");

	Params::Lib_C_GetCarpet Parms{};

	Parms.Param_Index = Param_Index;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function lib.lib_C.propToObject
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Prop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
// struct FStruct_food1                    FoodData                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Object                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Isfood                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FStruct_prop                     PropData                                               (Parm, OutParm, HasGetValueTypeHash)

bool ULib_C::PropToObject(class FName Prop, class UObject* __WorldContext, struct FStruct_food1* FoodData, class UClass** Object, bool* Isfood, struct FStruct_prop* PropData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "propToObject");

	Params::Lib_C_PropToObject Parms{};

	Parms.Prop = Prop;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (FoodData != nullptr)
		*FoodData = std::move(Parms.FoodData);

	if (Object != nullptr)
		*Object = Parms.Object;

	if (Isfood != nullptr)
		*Isfood = Parms.Isfood;

	if (PropData != nullptr)
		*PropData = std::move(Parms.PropData);

	return Parms.ReturnValue;
}


// Function lib.lib_C.getPic
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Dim                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture2D*                       Tex                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetPic(int32 Dim, int32 Param_Index, class UObject* __WorldContext, class UTexture2D** Tex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getPic");

	Params::Lib_C_GetPic Parms{};

	Parms.Dim = Dim;
	Parms.Param_Index = Param_Index;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Tex != nullptr)
		*Tex = Parms.Tex;
}


// Function lib.lib_C.getCusPic
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Dim                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture2D*                       Tex                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UTexture2D*>               Arra                                                   (Parm, OutParm)

void ULib_C::GetCusPic(int32 Dim, int32 Param_Index, class UObject* __WorldContext, class UTexture2D** Tex, TArray<class UTexture2D*>* Arra)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getCusPic");

	Params::Lib_C_GetCusPic Parms{};

	Parms.Dim = Dim;
	Parms.Param_Index = Param_Index;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Tex != nullptr)
		*Tex = Parms.Tex;

	if (Arra != nullptr)
		*Arra = std::move(Parms.Arra);
}


// Function lib.lib_C.GameVersion
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                           Prefix                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FString                           Suffix                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Version                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ULib_C::GameVersion(const class FString& Prefix, const class FString& Suffix, class UObject* __WorldContext, class FString* Version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "GameVersion");

	Params::Lib_C_GameVersion Parms{};

	Parms.Prefix = std::move(Prefix);
	Parms.Suffix = std::move(Suffix);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Version != nullptr)
		*Version = std::move(Parms.Version);
}


// Function lib.lib_C.setEvent
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEventActive                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::SetEvent(bool IsEventActive, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "setEvent");

	Params::Lib_C_SetEvent Parms{};

	Parms.IsEventActive = IsEventActive;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.getEvent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsEventActive                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::GetEvent(class UObject* __WorldContext, bool* IsEventActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getEvent");

	Params::Lib_C_GetEvent Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsEventActive != nullptr)
		*IsEventActive = Parms.IsEventActive;
}


// Function lib.lib_C.Get Key Bind
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FKey                             bind                                                   (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::Get_Key_Bind(const struct FKey& Key, class UObject* __WorldContext, struct FKey* bind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "Get Key Bind");

	Params::Lib_C_Get_Key_Bind Parms{};

	Parms.Key = std::move(Key);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bind != nullptr)
		*bind = std::move(Parms.bind);
}


// Function lib.lib_C.getBoyoancy
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPhysicalMaterial*                Phys                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetBoyoancy(class UPhysicalMaterial* Phys, class UPrimitiveComponent* Component, class UObject* __WorldContext, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getBoyoancy");

	Params::Lib_C_GetBoyoancy Parms{};

	Parms.Phys = Phys;
	Parms.Component = Component;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function lib.lib_C.propDescription
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Prop                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
// bool                                    AddName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             Desc                                                   (Parm, OutParm)
// class FText                             Param_Name                                             (Parm, OutParm)

void ULib_C::PropDescription(const class FString& Prop, bool AddName, class UObject* __WorldContext, class FText* Desc, class FText* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "propDescription");

	Params::Lib_C_PropDescription Parms{};

	Parms.Prop = std::move(Prop);
	Parms.AddName = AddName;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Desc != nullptr)
		*Desc = std::move(Parms.Desc);

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);
}


// Function lib.lib_C.propToIcon
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           ItemToFind                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture2D*                       Output                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::PropToIcon(const class FString& ItemToFind, class UObject* __WorldContext, class UTexture2D** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "propToIcon");

	Params::Lib_C_PropToIcon Parms{};

	Parms.ItemToFind = std::move(ItemToFind);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function lib.lib_C.propToDynamic
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_save                     Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_propDynamic              Equip                                                  (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::PropToDynamic(const struct FStruct_save& Data, class UObject* __WorldContext, struct FStruct_propDynamic* Equip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "propToDynamic");

	Params::Lib_C_PropToDynamic Parms{};

	Parms.Data = std::move(Data);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Equip != nullptr)
		*Equip = std::move(Parms.Equip);
}


// Function lib.lib_C.dynamicToProp
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_propDynamic              Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_save                     Equip                                                  (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::DynamicToProp(const struct FStruct_propDynamic& Data, class UObject* __WorldContext, struct FStruct_save* Equip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "dynamicToProp");

	Params::Lib_C_DynamicToProp Parms{};

	Parms.Data = std::move(Data);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Equip != nullptr)
		*Equip = std::move(Parms.Equip);
}


// Function lib.lib_C.getSaveSlot
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USaveSlot_C*                      SaveSlot                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetSaveSlot(class UObject* __WorldContext, class USaveSlot_C** SaveSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getSaveSlot");

	Params::Lib_C_GetSaveSlot Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SaveSlot != nullptr)
		*SaveSlot = Parms.SaveSlot;
}


// Function lib.lib_C.hasEquipment
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::HasEquipment(class FName Param_Name, class UObject* __WorldContext, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "hasEquipment");

	Params::Lib_C_HasEquipment Parms{};

	Parms.Param_Name = Param_Name;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function lib.lib_C.recountChildren
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPanelWidget*                     Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::RecountChildren(class UPanelWidget* Target, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "recountChildren");

	Params::Lib_C_RecountChildren Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.recountChildren_reverse
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPanelWidget*                     Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::RecountChildren_reverse(class UPanelWidget* Target, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "recountChildren_reverse");

	Params::Lib_C_RecountChildren_reverse Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.getMainSave
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USave_main_C*                     Save_main                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetMainSave(class UObject* __WorldContext, class USave_main_C** Save_main)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getMainSave");

	Params::Lib_C_GetMainSave Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Save_main != nullptr)
		*Save_main = Parms.Save_main;
}


// Function lib.lib_C.closestActor
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Nearest                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::ClosestActor(TArray<class AActor*>& Actors, const struct FVector& Location, class UObject* __WorldContext, class AActor** Nearest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "closestActor");

	Params::Lib_C_ClosestActor Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Actors = std::move(Parms.Actors);

	if (Nearest != nullptr)
		*Nearest = Parms.Nearest;
}


// Function lib.lib_C.closestClosedDoor
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ADoor_C*                          Output                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::ClosestClosedDoor(TArray<class AActor*>& Actors, const struct FVector& Location, class UObject* __WorldContext, class ADoor_C** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "closestClosedDoor");

	Params::Lib_C_ClosestClosedDoor Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Actors = std::move(Parms.Actors);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function lib.lib_C.ballistic
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   H                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::ballistic(const struct FVector& A, const struct FVector& B, float H, class UObject* __WorldContext, struct FVector* Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "ballistic");

	Params::Lib_C_ballistic Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.H = H;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Velocity != nullptr)
		*Velocity = std::move(Parms.Velocity);
}


// Function lib.lib_C.End
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::End(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "End");

	Params::Lib_C_End Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.hiddenSpawnMenu
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_prop                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Hidden                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Key                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::HiddenSpawnMenu(const struct FStruct_prop& Item, class UObject* __WorldContext, bool* Hidden, bool* Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "hiddenSpawnMenu");

	Params::Lib_C_HiddenSpawnMenu Parms{};

	Parms.Item = std::move(Item);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Hidden != nullptr)
		*Hidden = Parms.Hidden;

	if (Key != nullptr)
		*Key = Parms.Key;
}


// Function lib.lib_C.updateCollision
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::UpdateCollision(class UPrimitiveComponent* Component, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "updateCollision");

	Params::Lib_C_UpdateCollision Parms{};

	Parms.Component = Component;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.achievementObjects
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_prop                     Struct_prop                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Hidden                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::AchievementObjects(const struct FStruct_prop& Struct_prop, class UObject* __WorldContext, bool* Hidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "achievementObjects");

	Params::Lib_C_AchievementObjects Parms{};

	Parms.Struct_prop = std::move(Struct_prop);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Hidden != nullptr)
		*Hidden = Parms.Hidden;
}


// Function lib.lib_C.isMature
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Mature                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsMature(class UObject* __WorldContext, bool* Mature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isMature");

	Params::Lib_C_IsMature Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Mature != nullptr)
		*Mature = Parms.Mature;
}


// Function lib.lib_C.GetAssetFolder
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    SkipCreation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Path                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ULib_C::GetAssetFolder(bool SkipCreation, class UObject* __WorldContext, class FString* Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "GetAssetFolder");

	Params::Lib_C_GetAssetFolder Parms{};

	Parms.SkipCreation = SkipCreation;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Path != nullptr)
		*Path = std::move(Parms.Path);
}


// Function lib.lib_C.nameToSignal
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_signal_data1             Data                                                   (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::NameToSignal(class FName Param_Name, class UObject* __WorldContext, struct FStruct_signal_data1* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "nameToSignal");

	Params::Lib_C_NameToSignal Parms{};

	Parms.Param_Name = Param_Name;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = std::move(Parms.Data);
}


// Function lib.lib_C.signalToDynamic
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_signal_data1             Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_signalDataDynamic        Dynamic                                                (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::SignalToDynamic(const struct FStruct_signal_data1& Data, class UObject* __WorldContext, struct FStruct_signalDataDynamic* Dynamic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "signalToDynamic");

	Params::Lib_C_SignalToDynamic Parms{};

	Parms.Data = std::move(Data);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Dynamic != nullptr)
		*Dynamic = std::move(Parms.Dynamic);
}


// Function lib.lib_C.dynamicToSignal
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_signalDataDynamic        Dynamic                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_signal_data1             Data                                                   (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::DynamicToSignal(const struct FStruct_signalDataDynamic& Dynamic, class UObject* __WorldContext, struct FStruct_signal_data1* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "dynamicToSignal");

	Params::Lib_C_DynamicToSignal Parms{};

	Parms.Dynamic = std::move(Dynamic);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = std::move(Parms.Data);
}


// Function lib.lib_C.isSignalUnique
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Unique                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsSignalUnique(class FName Param_Name, class UObject* __WorldContext, bool* Unique)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isSignalUnique");

	Params::Lib_C_IsSignalUnique Parms{};

	Parms.Param_Name = Param_Name;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Unique != nullptr)
		*Unique = Parms.Unique;
}


// Function lib.lib_C.radioStations
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   StringArray                                            (Parm, OutParm)

void ULib_C::RadioStations(class UObject* __WorldContext, TArray<class FString>* StringArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "radioStations");

	Params::Lib_C_RadioStations Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (StringArray != nullptr)
		*StringArray = std::move(Parms.StringArray);
}


// Function lib.lib_C.isGeneratorsFine
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Fine                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsGeneratorsFine(class UObject* __WorldContext, bool* Fine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isGeneratorsFine");

	Params::Lib_C_IsGeneratorsFine Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Fine != nullptr)
		*Fine = Parms.Fine;
}


// Function lib.lib_C.isFlammable
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPhysicalMaterial*                Phys                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsFlammable                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsFlammable(const class UPhysicalMaterial*& Phys, class UObject* __WorldContext, bool* Param_IsFlammable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isFlammable");

	Params::Lib_C_IsFlammable Parms{};

	Parms.Phys = Phys;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Param_IsFlammable != nullptr)
		*Param_IsFlammable = Parms.Param_IsFlammable;
}


// Function lib.lib_C.findInventoryObject
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AutoRemove                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RemoveVol                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Array_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_save                     Array_Element                                          (Parm, OutParm, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::FindInventoryObject(class UClass* B, bool AutoRemove, bool RemoveVol, class UObject* __WorldContext, int32* Array_Index, struct FStruct_save* Array_Element, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "findInventoryObject");

	Params::Lib_C_FindInventoryObject Parms{};

	Parms.B = B;
	Parms.AutoRemove = AutoRemove;
	Parms.RemoveVol = RemoveVol;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Array_Index != nullptr)
		*Array_Index = Parms.Array_Index;

	if (Array_Element != nullptr)
		*Array_Element = std::move(Parms.Array_Element);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function lib.lib_C.getPosters
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture2D*                       Output                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetPosters(int32 Type, class UObject* __WorldContext, class UTexture2D** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getPosters");

	Params::Lib_C_GetPosters Parms{};

	Parms.Type = Type;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function lib.lib_C.isUnderwater
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ItemToFind                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ULib_C::IsUnderwater(const class AActor*& ItemToFind, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isUnderwater");

	Params::Lib_C_IsUnderwater Parms{};

	Parms.ItemToFind = ItemToFind;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function lib.lib_C.forbiddenMailProps
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FName>                     Props                                                  (Parm, OutParm)

void ULib_C::ForbiddenMailProps(class UObject* __WorldContext, TArray<class FName>* Props)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "forbiddenMailProps");

	Params::Lib_C_ForbiddenMailProps Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Props != nullptr)
		*Props = std::move(Parms.Props);
}


// Function lib.lib_C.getKeybindFromName
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Param_Name                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FKey                             bind                                                   (Parm, OutParm, HasGetValueTypeHash)

void ULib_C::GetKeybindFromName(const class FName Param_Name, class UObject* __WorldContext, struct FKey* bind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getKeybindFromName");

	Params::Lib_C_GetKeybindFromName Parms{};

	Parms.Param_Name = Param_Name;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bind != nullptr)
		*bind = std::move(Parms.bind);
}


// Function lib.lib_C.addGloss
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::AddGloss(class FName Param_Name, int32 Level, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "addGloss");

	Params::Lib_C_AddGloss Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Level = Level;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.generateAssetDirectory
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Path                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ULib_C::GenerateAssetDirectory(class UObject* __WorldContext, class FString* Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "generateAssetDirectory");

	Params::Lib_C_GenerateAssetDirectory Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Path != nullptr)
		*Path = std::move(Parms.Path);
}


// Function lib.lib_C.Get Volume
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Param_Name                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Mass                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::Get_Volume(const class UStaticMesh* Mesh, const class FString& Param_Name, class UObject* __WorldContext, float* Volume, float* Mass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "Get Volume");

	Params::Lib_C_Get_Volume Parms{};

	Parms.Mesh = Mesh;
	Parms.Param_Name = std::move(Param_Name);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Volume != nullptr)
		*Volume = Parms.Volume;

	if (Mass != nullptr)
		*Mass = Parms.Mass;
}


// Function lib.lib_C.step
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Z_offset                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           CallActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Pitch                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   SpeedVolume                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ULib_C::Step(class ACharacter* Character, float Z_offset, class AActor* CallActor, float Volume, float Pitch, float SpeedVolume, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "step");

	Params::Lib_C_Step Parms{};

	Parms.Character = Character;
	Parms.Z_offset = Z_offset;
	Parms.CallActor = CallActor;
	Parms.Volume = Volume;
	Parms.Pitch = Pitch;
	Parms.SpeedVolume = SpeedVolume;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);
}


// Function lib.lib_C.getAttachActorRoot
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           RootActor                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetAttachActorRoot(class AActor* Actor, class UObject* __WorldContext, class AActor** RootActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getAttachActorRoot");

	Params::Lib_C_GetAttachActorRoot Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (RootActor != nullptr)
		*RootActor = Parms.RootActor;
}


// Function lib.lib_C.isFunny
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsFunny                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::IsFunny(class UObject* __WorldContext, bool* Param_IsFunny)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "isFunny");

	Params::Lib_C_IsFunny Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Param_IsFunny != nullptr)
		*Param_IsFunny = Parms.Param_IsFunny;
}


// Function lib.lib_C.ariralRep
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rep                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::AriralRep(float Rep, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "ariralRep");

	Params::Lib_C_AriralRep Parms{};

	Parms.Rep = Rep;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.findInventoryObject_fromSlot
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_save                     Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// TArray<struct FStruct_save>             Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UClass*                           B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AutoRemove                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RemoveVol                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RemoveIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Array_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStruct_save                     Array_Element                                          (Parm, OutParm, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::FindInventoryObject_fromSlot(struct FStruct_save& Origin, TArray<struct FStruct_save>& Array, class UClass* B, bool AutoRemove, bool RemoveVol, bool RemoveIndex, class UObject* __WorldContext, int32* Array_Index, struct FStruct_save* Array_Element, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "findInventoryObject_fromSlot");

	Params::Lib_C_FindInventoryObject_fromSlot Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Array = std::move(Array);
	Parms.B = B;
	Parms.AutoRemove = AutoRemove;
	Parms.RemoveVol = RemoveVol;
	Parms.RemoveIndex = RemoveIndex;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Origin = std::move(Parms.Origin);
	Array = std::move(Parms.Array);

	if (Array_Index != nullptr)
		*Array_Index = Parms.Array_Index;

	if (Array_Element != nullptr)
		*Array_Element = std::move(Parms.Array_Element);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function lib.lib_C.hiddens
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<bool>                            Param_Hiddens                                          (Parm, OutParm)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)

class FString ULib_C::Hiddens(class UObject* __WorldContext, TArray<bool>* Param_Hiddens)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "hiddens");

	Params::Lib_C_Hiddens Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Param_Hiddens != nullptr)
		*Param_Hiddens = std::move(Parms.Param_Hiddens);

	return Parms.ReturnValue;
}


// Function lib.lib_C.customWall_getBricks
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ActorScale                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Shape                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ToCeil                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::CustomWall_getBricks(const struct FVector& ActorScale, int32 Shape, class UObject* __WorldContext, float* ToCeil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "customWall_getBricks");

	Params::Lib_C_CustomWall_getBricks Parms{};

	Parms.ActorScale = std::move(ActorScale);
	Parms.Shape = Shape;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ToCeil != nullptr)
		*ToCeil = Parms.ToCeil;
}


// Function lib.lib_C.customWall_shape
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*                      Shape                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::CustomWall_shape(int32 Type, class UObject* __WorldContext, class UStaticMesh** Shape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "customWall_shape");

	Params::Lib_C_CustomWall_shape Parms{};

	Parms.Type = Type;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Shape != nullptr)
		*Shape = Parms.Shape;
}


// Function lib.lib_C.customWall_material
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               Material                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Drop                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Requirement                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::CustomWall_material(int32 Type, class UObject* __WorldContext, class UMaterialInterface** Material, class FName* Drop, class FName* Requirement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "customWall_material");

	Params::Lib_C_CustomWall_material Parms{};

	Parms.Type = Type;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Material != nullptr)
		*Material = Parms.Material;

	if (Drop != nullptr)
		*Drop = Parms.Drop;

	if (Requirement != nullptr)
		*Requirement = Parms.Requirement;
}


// Function lib.lib_C.sellObject
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyShop                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           ObjectToSell                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Points                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Sold                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ULib_C::SellObject(class FName Object, bool OnlyShop, class AActor* ObjectToSell, class UObject* __WorldContext, int32* Points, bool* Sold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "sellObject");

	Params::Lib_C_SellObject Parms{};

	Parms.Object = Object;
	Parms.OnlyShop = OnlyShop;
	Parms.ObjectToSell = ObjectToSell;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Points != nullptr)
		*Points = Parms.Points;

	if (Sold != nullptr)
		*Sold = Parms.Sold;
}


// Function lib.lib_C.safeAsProp
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AProp_C*                          Prop                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::SafeAsProp(class AActor* Actor, class UObject* __WorldContext, bool* IsValid, class AProp_C** Prop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "safeAsProp");

	Params::Lib_C_SafeAsProp Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	if (Prop != nullptr)
		*Prop = Parms.Prop;
}


// Function lib.lib_C.detecCyr
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Text                                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString                           Str1                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ULib_C::DetecCyr(const class FText& Text, class UObject* __WorldContext, bool* Return, class FString* Str1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "detecCyr");

	Params::Lib_C_DetecCyr Parms{};

	Parms.Text = std::move(Text);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;

	if (Str1 != nullptr)
		*Str1 = std::move(Parms.Str1);
}


// Function lib.lib_C.lag
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::Lag(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "lag");

	Params::Lib_C_Lag Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.propToName
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           ItemToFind                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             Output                                                 (Parm, OutParm)

void ULib_C::PropToName(const class FString& ItemToFind, class UObject* __WorldContext, class FText* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "propToName");

	Params::Lib_C_PropToName Parms{};

	Parms.ItemToFind = std::move(ItemToFind);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = std::move(Parms.Output);
}


// Function lib.lib_C.getMoonPhase
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Phase                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::GetMoonPhase(class UObject* __WorldContext, float* Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "getMoonPhase");

	Params::Lib_C_GetMoonPhase Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Phase != nullptr)
		*Phase = Parms.Phase;
}


// Function lib.lib_C.addEffect
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Effect                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Strength                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IncrementStrength                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IncrementTime                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::AddEffect(class FName Effect, float Strength, float Time, bool IncrementStrength, bool IncrementTime, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "addEffect");

	Params::Lib_C_AddEffect Parms{};

	Parms.Effect = Effect;
	Parms.Strength = Strength;
	Parms.Time = Time;
	Parms.IncrementStrength = IncrementStrength;
	Parms.IncrementTime = IncrementTime;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function lib.lib_C.generateKey
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           KeyIn                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
// class AActor*                           Object                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           KeyOut                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ULib_C::GenerateKey(class FString& KeyIn, const class AActor*& Object, class UObject* __WorldContext, class FString* KeyOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "generateKey");

	Params::Lib_C_GenerateKey Parms{};

	Parms.KeyIn = std::move(KeyIn);
	Parms.Object = Object;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	KeyIn = std::move(Parms.KeyIn);

	if (KeyOut != nullptr)
		*KeyOut = std::move(Parms.KeyOut);
}


// Function lib.lib_C.debugSound
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ULib_C::DebugSound(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("lib_C", "debugSound");

	Params::Lib_C_DebugSound Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}

}

