#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VotV

#include "Basic.hpp"

#include "VotV_classes.hpp"
#include "VotV_parameters.hpp"


namespace SDK
{

// Function VotV.bpCodeLib.BoundingBox2D
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Comp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Verts                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector2D                        Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClipX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClipY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::BoundingBox2D(class APlayerController* PlayerController, class UPrimitiveComponent* Comp, TArray<struct FVector>* Verts, struct FVector2D* Min, struct FVector2D* Max, struct FVector2D* Origin, struct FVector2D* Size, bool* ClipX, bool* ClipY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "BoundingBox2D");

	Params::bpCodeLib_BoundingBox2D Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Comp = Comp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Verts != nullptr)
		*Verts = std::move(Parms.Verts);

	if (Min != nullptr)
		*Min = std::move(Parms.Min);

	if (Max != nullptr)
		*Max = std::move(Parms.Max);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (ClipX != nullptr)
		*ClipX = Parms.ClipX;

	if (ClipY != nullptr)
		*ClipY = Parms.ClipY;
}


// Function VotV.bpCodeLib.BoundingBox2DPoints
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Verts                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector2D                        Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClipX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClipY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::BoundingBox2DPoints(class APlayerController* PlayerController, const TArray<struct FVector>& Verts, struct FVector2D* Min, struct FVector2D* Max, struct FVector2D* Origin, struct FVector2D* Size, bool* ClipX, bool* ClipY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "BoundingBox2DPoints");

	Params::bpCodeLib_BoundingBox2DPoints Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Verts = std::move(Verts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Min != nullptr)
		*Min = std::move(Parms.Min);

	if (Max != nullptr)
		*Max = std::move(Parms.Max);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (ClipX != nullptr)
		*ClipX = Parms.ClipX;

	if (ClipY != nullptr)
		*ClipY = Parms.ClipY;
}


// Function VotV.bpCodeLib.boyoancy
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ActorsInWater                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           ActorsSurface                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           ActorsBoyoancy                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               Boxes                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            CenterUnderwaterCompare                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            CenterUnderwaterCopy                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   PowerDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPower                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USplineComponent*>         RiverSplines                                           (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<float>                           RiversRadiusIn                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           RiversRadiusOut                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           RiversForce                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Damping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::boyoancy(const TArray<class AActor*>& ActorsInWater, const TArray<float>& ActorsSurface, const TArray<float>& ActorsBoyoancy, const TArray<struct FTransform>& Boxes, const TArray<bool>& CenterUnderwaterCompare, TArray<bool>* CenterUnderwaterCopy, float PowerDepth, float MaxPower, const TArray<class USplineComponent*>& RiverSplines, const TArray<float>& RiversRadiusIn, const TArray<float>& RiversRadiusOut, const TArray<float>& RiversForce, float Damping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "boyoancy");

	Params::bpCodeLib_boyoancy Parms{};

	Parms.ActorsInWater = std::move(ActorsInWater);
	Parms.ActorsSurface = std::move(ActorsSurface);
	Parms.ActorsBoyoancy = std::move(ActorsBoyoancy);
	Parms.Boxes = std::move(Boxes);
	Parms.CenterUnderwaterCompare = std::move(CenterUnderwaterCompare);
	Parms.PowerDepth = PowerDepth;
	Parms.MaxPower = MaxPower;
	Parms.RiverSplines = std::move(RiverSplines);
	Parms.RiversRadiusIn = std::move(RiversRadiusIn);
	Parms.RiversRadiusOut = std::move(RiversRadiusOut);
	Parms.RiversForce = std::move(RiversForce);
	Parms.Damping = Damping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CenterUnderwaterCopy != nullptr)
		*CenterUnderwaterCopy = std::move(Parms.CenterUnderwaterCopy);
}


// Function VotV.bpCodeLib.boyoancyForce
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_boyoancyForce                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Surface                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PowerDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPower                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::boyoancyForce(class UPrimitiveComponent* Component, float Param_boyoancyForce, float Surface, float PowerDepth, float MaxPower, float Damping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "boyoancyForce");

	Params::bpCodeLib_boyoancyForce Parms{};

	Parms.Component = Component;
	Parms.Param_boyoancyForce = Param_boyoancyForce;
	Parms.Surface = Surface;
	Parms.PowerDepth = PowerDepth;
	Parms.MaxPower = MaxPower;
	Parms.Damping = Damping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VotV.bpCodeLib.canBoxFitInBox
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          big                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Small                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UbpCodeLib::CanBoxFitInBox(const struct FVector& big, const struct FVector& Small)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "canBoxFitInBox");

	Params::bpCodeLib_CanBoxFitInBox Parms{};

	Parms.big = std::move(big);
	Parms.Small = std::move(Small);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VotV.bpCodeLib.getMachineID
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UbpCodeLib::GetMachineID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "getMachineID");

	Params::bpCodeLib_GetMachineID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VotV.bpCodeLib.getMotion
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FColor>                   Pixels_a                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FColor>                   Pixels_b                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::GetMotion(const TArray<struct FColor>& Pixels_a, const TArray<struct FColor>& Pixels_b, float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "getMotion");

	Params::bpCodeLib_GetMotion Parms{};

	Parms.Pixels_a = std::move(Pixels_a);
	Parms.Pixels_b = std::move(Pixels_b);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VotV.bpCodeLib.meshConvexVolume
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Depth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Iters                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinVol                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Points                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UbpCodeLib::MeshConvexVolume(class UStaticMeshComponent* StaticMesh, int32 Depth, float* Volume, int32* Iters, float* MinVol, TArray<struct FVector>* Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "meshConvexVolume");

	Params::bpCodeLib_MeshConvexVolume Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.Depth = Depth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Volume != nullptr)
		*Volume = Parms.Volume;

	if (Iters != nullptr)
		*Iters = Parms.Iters;

	if (MinVol != nullptr)
		*MinVol = Parms.MinVol;

	if (Points != nullptr)
		*Points = std::move(Parms.Points);
}


// Function VotV.bpCodeLib.meshConvexVolume2
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::MeshConvexVolume2(class UStaticMeshComponent* StaticMesh, float* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "meshConvexVolume2");

	Params::bpCodeLib_MeshConvexVolume2 Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Volume != nullptr)
		*Volume = Parms.Volume;
}


// Function VotV.bpCodeLib.processPhysImpact
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       ImpactSound                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       DamageSound                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       DestroySound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                Attenuation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                Concurrency                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpactResistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpactDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageResistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugFloat1                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DebugBool1                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::ProcessPhysImpact(class AActor* Object, class UPrimitiveComponent* Component, const struct FHitResult& Hit, const struct FVector& Impact, class USoundBase* ImpactSound, class USoundBase* DamageSound, class USoundBase* DestroySound, class USoundAttenuation* Attenuation, class USoundConcurrency* Concurrency, float CurrentHealth, float ImpactResistance, float ImpactDamage, float DamageResistance, float Mass, bool* IsHit, float* DebugFloat1, bool* DebugBool1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "processPhysImpact");

	Params::bpCodeLib_ProcessPhysImpact Parms{};

	Parms.Object = Object;
	Parms.Component = Component;
	Parms.Hit = std::move(Hit);
	Parms.Impact = std::move(Impact);
	Parms.ImpactSound = ImpactSound;
	Parms.DamageSound = DamageSound;
	Parms.DestroySound = DestroySound;
	Parms.Attenuation = Attenuation;
	Parms.Concurrency = Concurrency;
	Parms.CurrentHealth = CurrentHealth;
	Parms.ImpactResistance = ImpactResistance;
	Parms.ImpactDamage = ImpactDamage;
	Parms.DamageResistance = DamageResistance;
	Parms.Mass = Mass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsHit != nullptr)
		*IsHit = Parms.IsHit;

	if (DebugFloat1 != nullptr)
		*DebugFloat1 = Parms.DebugFloat1;

	if (DebugBool1 != nullptr)
		*DebugBool1 = Parms.DebugBool1;
}


// Function VotV.bpCodeLib.rugGen
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Size_X                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Size_Y                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lift                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRad                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxSm                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Verts                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Tris                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Normals                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                UVs                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UbpCodeLib::RugGen(class AActor* Owner, int32 Size_X, int32 Size_Y, float Size, float Height, float Lift, float TraceSize, float MaxRad, int32 MaxSm, TArray<struct FVector>* Verts, TArray<int32>* Tris, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "rugGen");

	Params::bpCodeLib_RugGen Parms{};

	Parms.Owner = Owner;
	Parms.Size_X = Size_X;
	Parms.Size_Y = Size_Y;
	Parms.Size = Size;
	Parms.Height = Height;
	Parms.Lift = Lift;
	Parms.TraceSize = TraceSize;
	Parms.MaxRad = MaxRad;
	Parms.MaxSm = MaxSm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Verts != nullptr)
		*Verts = std::move(Parms.Verts);

	if (Tris != nullptr)
		*Tris = std::move(Parms.Tris);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (UVs != nullptr)
		*UVs = std::move(Parms.UVs);
}


// Function VotV.bpCodeLib.scrapingMath
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAudioComponent*                  Audio                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanScrape                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Vol                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::ScrapingMath(class UPrimitiveComponent* Component, const struct FHitResult& Hit, class UAudioComponent* Audio, bool* CanScrape, float& Vol)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "scrapingMath");

	Params::bpCodeLib_ScrapingMath Parms{};

	Parms.Component = Component;
	Parms.Hit = std::move(Hit);
	Parms.Audio = Audio;
	Parms.Vol = Vol;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Vol = Parms.Vol;

	if (CanScrape != nullptr)
		*CanScrape = Parms.CanScrape;
}


// Function VotV.bpCodeLib.stringEquation
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Equation                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Answer                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::StringEquation(const class FString& Equation, float* Answer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "stringEquation");

	Params::bpCodeLib_StringEquation Parms{};

	Parms.Equation = std::move(Equation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Answer != nullptr)
		*Answer = Parms.Answer;
}


// Function VotV.bpCodeLib.tetrahedronVolume
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          VecA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          VecB                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          VecC                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          VecD                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UbpCodeLib::TetrahedronVolume(const struct FVector& VecA, const struct FVector& VecB, const struct FVector& VecC, const struct FVector& VecD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "tetrahedronVolume");

	Params::bpCodeLib_TetrahedronVolume Parms{};

	Parms.VecA = std::move(VecA);
	Parms.VecB = std::move(VecB);
	Parms.VecC = std::move(VecC);
	Parms.VecD = std::move(VecD);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VotV.bpCodeLib.translateAriral
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           In                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Out                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::TranslateAriral(const class FString& In, class FString* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "translateAriral");

	Params::bpCodeLib_TranslateAriral Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);
}


// Function VotV.bpCodeLib.triangleNormal
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Point1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point3                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::TriangleNormal(const struct FVector& Point1, const struct FVector& Point2, const struct FVector& Point3, struct FVector* Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "triangleNormal");

	Params::bpCodeLib_TriangleNormal Parms{};

	Parms.Point1 = std::move(Point1);
	Parms.Point2 = std::move(Point2);
	Parms.Point3 = std::move(Point3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);
}


// Function VotV.bpCodeLib.vecBoundBox
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Vecs                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Box                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          boundingCenter                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::VecBoundBox(const TArray<struct FVector>& Vecs, struct FVector* Min, struct FVector* Max, struct FVector* Box, struct FVector* Origin, struct FVector* boundingCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "vecBoundBox");

	Params::bpCodeLib_VecBoundBox Parms{};

	Parms.Vecs = std::move(Vecs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Min != nullptr)
		*Min = std::move(Parms.Min);

	if (Max != nullptr)
		*Max = std::move(Parms.Max);

	if (Box != nullptr)
		*Box = std::move(Parms.Box);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (boundingCenter != nullptr)
		*boundingCenter = std::move(Parms.boundingCenter);
}


// Function VotV.bpCodeLib.weightedRandomV2
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Weights                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::WeightedRandomV2(const TArray<float>& Weights, int32* Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "weightedRandomV2");

	Params::bpCodeLib_WeightedRandomV2 Parms{};

	Parms.Weights = std::move(Weights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function VotV.bpCodeLib.weightedRandomV2_exponent
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Weights                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Exponent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::WeightedRandomV2_exponent(const TArray<float>& Weights, float Exponent, int32* Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "weightedRandomV2_exponent");

	Params::bpCodeLib_WeightedRandomV2_exponent Parms{};

	Parms.Weights = std::move(Weights);
	Parms.Exponent = Exponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function VotV.bpCodeLib.weightedRandomV2_lerp
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Weights                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Ulerp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UbpCodeLib::WeightedRandomV2_lerp(const TArray<float>& Weights, float Ulerp, int32* Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("bpCodeLib", "weightedRandomV2_lerp");

	Params::bpCodeLib_WeightedRandomV2_lerp Parms{};

	Parms.Weights = std::move(Weights);
	Parms.Ulerp = Ulerp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function VotV.bpCodeLib.GetAllAttachedActors
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AActor*                           ParentActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UbpCodeLib::GetAllAttachedActors(class AActor* ParentActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("bpCodeLib", "GetAllAttachedActors");

	Params::bpCodeLib_GetAllAttachedActors Parms{};

	Parms.ParentActor = ParentActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VotV.cppInterface.enteredTheWater
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICppInterface::EnteredTheWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("cppInterface", "enteredTheWater");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function VotV.cppInterface.exitTheWater
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICppInterface::ExitTheWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("cppInterface", "exitTheWater");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function VotV.cppInterface.impactDamageCPP
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICppInterface::ImpactDamageCPP(float Damage, const struct FHitResult& Hit, class AActor* Actor, const struct FVector& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("cppInterface", "impactDamageCPP");

	Params::CppInterface_ImpactDamageCPP Parms{};

	Parms.Damage = Damage;
	Parms.Hit = std::move(Hit);
	Parms.Actor = Actor;
	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VotV.cppInterface.impactSquishCPP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICppInterface::ImpactSquishCPP(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("cppInterface", "impactSquishCPP");

	Params::CppInterface_ImpactSquishCPP Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

