#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VotV

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function VotV.bpCodeLib.BoundingBox2D
// 0x0048 (0x0048 - 0x0000)
struct bpCodeLib_BoundingBox2D final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Comp;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Verts;                                             // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Min;                                               // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Max;                                               // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Origin;                                            // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClipX;                                             // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClipY;                                             // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BD[0x6];                                     // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_BoundingBox2D) == 0x000008, "Wrong alignment on bpCodeLib_BoundingBox2D");
static_assert(sizeof(bpCodeLib_BoundingBox2D) == 0x000048, "Wrong size on bpCodeLib_BoundingBox2D");
static_assert(offsetof(bpCodeLib_BoundingBox2D, PlayerController) == 0x000000, "Member 'bpCodeLib_BoundingBox2D::PlayerController' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, Comp) == 0x000008, "Member 'bpCodeLib_BoundingBox2D::Comp' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, Verts) == 0x000010, "Member 'bpCodeLib_BoundingBox2D::Verts' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, Min) == 0x000020, "Member 'bpCodeLib_BoundingBox2D::Min' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, Max) == 0x000028, "Member 'bpCodeLib_BoundingBox2D::Max' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, Origin) == 0x000030, "Member 'bpCodeLib_BoundingBox2D::Origin' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, Size) == 0x000038, "Member 'bpCodeLib_BoundingBox2D::Size' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, ClipX) == 0x000040, "Member 'bpCodeLib_BoundingBox2D::ClipX' has a wrong offset!");
static_assert(offsetof(bpCodeLib_BoundingBox2D, ClipY) == 0x000041, "Member 'bpCodeLib_BoundingBox2D::ClipY' has a wrong offset!");

// Function VotV.bpCodeLib.boyoancy
// 0x00A8 (0x00A8 - 0x0000)
struct bpCodeLib_boyoancy final
{
public:
	TArray<class AActor*>                         ActorsInWater;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ActorsSurface;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ActorsBoyoancy;                                    // 0x0020(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Boxes;                                             // 0x0030(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  CenterUnderwaterCompare;                           // 0x0040(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  CenterUnderwaterCopy;                              // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PowerDepth;                                        // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPower;                                          // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineComponent*>               RiverSplines;                                      // 0x0068(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                 RiversRadiusIn;                                    // 0x0078(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RiversRadiusOut;                                   // 0x0088(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RiversForce;                                       // 0x0098(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_boyoancy) == 0x000008, "Wrong alignment on bpCodeLib_boyoancy");
static_assert(sizeof(bpCodeLib_boyoancy) == 0x0000A8, "Wrong size on bpCodeLib_boyoancy");
static_assert(offsetof(bpCodeLib_boyoancy, ActorsInWater) == 0x000000, "Member 'bpCodeLib_boyoancy::ActorsInWater' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, ActorsSurface) == 0x000010, "Member 'bpCodeLib_boyoancy::ActorsSurface' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, ActorsBoyoancy) == 0x000020, "Member 'bpCodeLib_boyoancy::ActorsBoyoancy' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, Boxes) == 0x000030, "Member 'bpCodeLib_boyoancy::Boxes' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, CenterUnderwaterCompare) == 0x000040, "Member 'bpCodeLib_boyoancy::CenterUnderwaterCompare' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, CenterUnderwaterCopy) == 0x000050, "Member 'bpCodeLib_boyoancy::CenterUnderwaterCopy' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, PowerDepth) == 0x000060, "Member 'bpCodeLib_boyoancy::PowerDepth' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, MaxPower) == 0x000064, "Member 'bpCodeLib_boyoancy::MaxPower' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, RiverSplines) == 0x000068, "Member 'bpCodeLib_boyoancy::RiverSplines' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, RiversRadiusIn) == 0x000078, "Member 'bpCodeLib_boyoancy::RiversRadiusIn' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, RiversRadiusOut) == 0x000088, "Member 'bpCodeLib_boyoancy::RiversRadiusOut' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancy, RiversForce) == 0x000098, "Member 'bpCodeLib_boyoancy::RiversForce' has a wrong offset!");

// Function VotV.bpCodeLib.boyoancyForce
// 0x0018 (0x0018 - 0x0000)
struct bpCodeLib_boyoancyForce final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param_boyoancyForce;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Surface;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerDepth;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPower;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_boyoancyForce) == 0x000008, "Wrong alignment on bpCodeLib_boyoancyForce");
static_assert(sizeof(bpCodeLib_boyoancyForce) == 0x000018, "Wrong size on bpCodeLib_boyoancyForce");
static_assert(offsetof(bpCodeLib_boyoancyForce, Component) == 0x000000, "Member 'bpCodeLib_boyoancyForce::Component' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancyForce, Param_boyoancyForce) == 0x000008, "Member 'bpCodeLib_boyoancyForce::Param_boyoancyForce' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancyForce, Surface) == 0x00000C, "Member 'bpCodeLib_boyoancyForce::Surface' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancyForce, PowerDepth) == 0x000010, "Member 'bpCodeLib_boyoancyForce::PowerDepth' has a wrong offset!");
static_assert(offsetof(bpCodeLib_boyoancyForce, MaxPower) == 0x000014, "Member 'bpCodeLib_boyoancyForce::MaxPower' has a wrong offset!");

// Function VotV.bpCodeLib.canBoxFitInBox
// 0x001C (0x001C - 0x0000)
struct bpCodeLib_CanBoxFitInBox final
{
public:
	struct FVector                                big;                                               // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Small;                                             // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BE[0x3];                                     // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_CanBoxFitInBox) == 0x000004, "Wrong alignment on bpCodeLib_CanBoxFitInBox");
static_assert(sizeof(bpCodeLib_CanBoxFitInBox) == 0x00001C, "Wrong size on bpCodeLib_CanBoxFitInBox");
static_assert(offsetof(bpCodeLib_CanBoxFitInBox, big) == 0x000000, "Member 'bpCodeLib_CanBoxFitInBox::big' has a wrong offset!");
static_assert(offsetof(bpCodeLib_CanBoxFitInBox, Small) == 0x00000C, "Member 'bpCodeLib_CanBoxFitInBox::Small' has a wrong offset!");
static_assert(offsetof(bpCodeLib_CanBoxFitInBox, ReturnValue) == 0x000018, "Member 'bpCodeLib_CanBoxFitInBox::ReturnValue' has a wrong offset!");

// Function VotV.bpCodeLib.getMachineID
// 0x0010 (0x0010 - 0x0000)
struct bpCodeLib_GetMachineID final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_GetMachineID) == 0x000008, "Wrong alignment on bpCodeLib_GetMachineID");
static_assert(sizeof(bpCodeLib_GetMachineID) == 0x000010, "Wrong size on bpCodeLib_GetMachineID");
static_assert(offsetof(bpCodeLib_GetMachineID, ReturnValue) == 0x000000, "Member 'bpCodeLib_GetMachineID::ReturnValue' has a wrong offset!");

// Function VotV.bpCodeLib.getMotion
// 0x0028 (0x0028 - 0x0000)
struct bpCodeLib_GetMotion final
{
public:
	TArray<struct FColor>                         Pixels_a;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         Pixels_b;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BF[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_GetMotion) == 0x000008, "Wrong alignment on bpCodeLib_GetMotion");
static_assert(sizeof(bpCodeLib_GetMotion) == 0x000028, "Wrong size on bpCodeLib_GetMotion");
static_assert(offsetof(bpCodeLib_GetMotion, Pixels_a) == 0x000000, "Member 'bpCodeLib_GetMotion::Pixels_a' has a wrong offset!");
static_assert(offsetof(bpCodeLib_GetMotion, Pixels_b) == 0x000010, "Member 'bpCodeLib_GetMotion::Pixels_b' has a wrong offset!");
static_assert(offsetof(bpCodeLib_GetMotion, Result) == 0x000020, "Member 'bpCodeLib_GetMotion::Result' has a wrong offset!");

// Function VotV.bpCodeLib.meshConvexVolume
// 0x0028 (0x0028 - 0x0000)
struct bpCodeLib_MeshConvexVolume final
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Depth;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Iters;                                             // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVol;                                            // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_MeshConvexVolume) == 0x000008, "Wrong alignment on bpCodeLib_MeshConvexVolume");
static_assert(sizeof(bpCodeLib_MeshConvexVolume) == 0x000028, "Wrong size on bpCodeLib_MeshConvexVolume");
static_assert(offsetof(bpCodeLib_MeshConvexVolume, StaticMesh) == 0x000000, "Member 'bpCodeLib_MeshConvexVolume::StaticMesh' has a wrong offset!");
static_assert(offsetof(bpCodeLib_MeshConvexVolume, Depth) == 0x000008, "Member 'bpCodeLib_MeshConvexVolume::Depth' has a wrong offset!");
static_assert(offsetof(bpCodeLib_MeshConvexVolume, Volume) == 0x00000C, "Member 'bpCodeLib_MeshConvexVolume::Volume' has a wrong offset!");
static_assert(offsetof(bpCodeLib_MeshConvexVolume, Iters) == 0x000010, "Member 'bpCodeLib_MeshConvexVolume::Iters' has a wrong offset!");
static_assert(offsetof(bpCodeLib_MeshConvexVolume, MinVol) == 0x000014, "Member 'bpCodeLib_MeshConvexVolume::MinVol' has a wrong offset!");
static_assert(offsetof(bpCodeLib_MeshConvexVolume, Points) == 0x000018, "Member 'bpCodeLib_MeshConvexVolume::Points' has a wrong offset!");

// Function VotV.bpCodeLib.meshConvexVolume2
// 0x0010 (0x0010 - 0x0000)
struct bpCodeLib_MeshConvexVolume2 final
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C0[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_MeshConvexVolume2) == 0x000008, "Wrong alignment on bpCodeLib_MeshConvexVolume2");
static_assert(sizeof(bpCodeLib_MeshConvexVolume2) == 0x000010, "Wrong size on bpCodeLib_MeshConvexVolume2");
static_assert(offsetof(bpCodeLib_MeshConvexVolume2, StaticMesh) == 0x000000, "Member 'bpCodeLib_MeshConvexVolume2::StaticMesh' has a wrong offset!");
static_assert(offsetof(bpCodeLib_MeshConvexVolume2, Volume) == 0x000008, "Member 'bpCodeLib_MeshConvexVolume2::Volume' has a wrong offset!");

// Function VotV.bpCodeLib.processPhysImpact
// 0x00F0 (0x00F0 - 0x0000)
struct bpCodeLib_ProcessPhysImpact final
{
public:
	class AActor*                                 Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Component;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0010(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Impact;                                            // 0x0098(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C1[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ImpactSound;                                       // 0x00A8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DamageSound;                                       // 0x00B0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DestroySound;                                      // 0x00B8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      Attenuation;                                       // 0x00C0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      Concurrency;                                       // 0x00C8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHealth;                                     // 0x00D0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactResistance;                                  // 0x00D4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactDamage;                                      // 0x00D8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistance;                                  // 0x00DC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x00E0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHit;                                             // 0x00E4(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C2[0x3];                                     // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugFloat1;                                       // 0x00E8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugBool1;                                        // 0x00EC(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C3[0x3];                                     // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_ProcessPhysImpact) == 0x000008, "Wrong alignment on bpCodeLib_ProcessPhysImpact");
static_assert(sizeof(bpCodeLib_ProcessPhysImpact) == 0x0000F0, "Wrong size on bpCodeLib_ProcessPhysImpact");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Object) == 0x000000, "Member 'bpCodeLib_ProcessPhysImpact::Object' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Component) == 0x000008, "Member 'bpCodeLib_ProcessPhysImpact::Component' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Hit) == 0x000010, "Member 'bpCodeLib_ProcessPhysImpact::Hit' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Impact) == 0x000098, "Member 'bpCodeLib_ProcessPhysImpact::Impact' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, ImpactSound) == 0x0000A8, "Member 'bpCodeLib_ProcessPhysImpact::ImpactSound' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, DamageSound) == 0x0000B0, "Member 'bpCodeLib_ProcessPhysImpact::DamageSound' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, DestroySound) == 0x0000B8, "Member 'bpCodeLib_ProcessPhysImpact::DestroySound' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Attenuation) == 0x0000C0, "Member 'bpCodeLib_ProcessPhysImpact::Attenuation' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Concurrency) == 0x0000C8, "Member 'bpCodeLib_ProcessPhysImpact::Concurrency' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, CurrentHealth) == 0x0000D0, "Member 'bpCodeLib_ProcessPhysImpact::CurrentHealth' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, ImpactResistance) == 0x0000D4, "Member 'bpCodeLib_ProcessPhysImpact::ImpactResistance' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, ImpactDamage) == 0x0000D8, "Member 'bpCodeLib_ProcessPhysImpact::ImpactDamage' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, DamageResistance) == 0x0000DC, "Member 'bpCodeLib_ProcessPhysImpact::DamageResistance' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, Mass) == 0x0000E0, "Member 'bpCodeLib_ProcessPhysImpact::Mass' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, IsHit) == 0x0000E4, "Member 'bpCodeLib_ProcessPhysImpact::IsHit' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, DebugFloat1) == 0x0000E8, "Member 'bpCodeLib_ProcessPhysImpact::DebugFloat1' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ProcessPhysImpact, DebugBool1) == 0x0000EC, "Member 'bpCodeLib_ProcessPhysImpact::DebugBool1' has a wrong offset!");

// Function VotV.bpCodeLib.rugGen
// 0x0068 (0x0068 - 0x0000)
struct bpCodeLib_RugGen final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size_X;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size_Y;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lift;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSize;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRad;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSm;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Verts;                                             // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Tris;                                              // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Normals;                                           // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      UVs;                                               // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_RugGen) == 0x000008, "Wrong alignment on bpCodeLib_RugGen");
static_assert(sizeof(bpCodeLib_RugGen) == 0x000068, "Wrong size on bpCodeLib_RugGen");
static_assert(offsetof(bpCodeLib_RugGen, Owner) == 0x000000, "Member 'bpCodeLib_RugGen::Owner' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Size_X) == 0x000008, "Member 'bpCodeLib_RugGen::Size_X' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Size_Y) == 0x00000C, "Member 'bpCodeLib_RugGen::Size_Y' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Size) == 0x000010, "Member 'bpCodeLib_RugGen::Size' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Height) == 0x000014, "Member 'bpCodeLib_RugGen::Height' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Lift) == 0x000018, "Member 'bpCodeLib_RugGen::Lift' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, TraceSize) == 0x00001C, "Member 'bpCodeLib_RugGen::TraceSize' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, MaxRad) == 0x000020, "Member 'bpCodeLib_RugGen::MaxRad' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, MaxSm) == 0x000024, "Member 'bpCodeLib_RugGen::MaxSm' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Verts) == 0x000028, "Member 'bpCodeLib_RugGen::Verts' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Tris) == 0x000038, "Member 'bpCodeLib_RugGen::Tris' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, Normals) == 0x000048, "Member 'bpCodeLib_RugGen::Normals' has a wrong offset!");
static_assert(offsetof(bpCodeLib_RugGen, UVs) == 0x000058, "Member 'bpCodeLib_RugGen::UVs' has a wrong offset!");

// Function VotV.bpCodeLib.scrapingMath
// 0x00A0 (0x00A0 - 0x0000)
struct bpCodeLib_ScrapingMath final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio;                                             // 0x0090(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanScrape;                                         // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C4[0x3];                                     // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Vol;                                               // 0x009C(0x0004)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_ScrapingMath) == 0x000008, "Wrong alignment on bpCodeLib_ScrapingMath");
static_assert(sizeof(bpCodeLib_ScrapingMath) == 0x0000A0, "Wrong size on bpCodeLib_ScrapingMath");
static_assert(offsetof(bpCodeLib_ScrapingMath, Component) == 0x000000, "Member 'bpCodeLib_ScrapingMath::Component' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ScrapingMath, Hit) == 0x000008, "Member 'bpCodeLib_ScrapingMath::Hit' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ScrapingMath, Audio) == 0x000090, "Member 'bpCodeLib_ScrapingMath::Audio' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ScrapingMath, CanScrape) == 0x000098, "Member 'bpCodeLib_ScrapingMath::CanScrape' has a wrong offset!");
static_assert(offsetof(bpCodeLib_ScrapingMath, Vol) == 0x00009C, "Member 'bpCodeLib_ScrapingMath::Vol' has a wrong offset!");

// Function VotV.bpCodeLib.stringEquation
// 0x0018 (0x0018 - 0x0000)
struct bpCodeLib_StringEquation final
{
public:
	class FString                                 Equation;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Answer;                                            // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C5[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_StringEquation) == 0x000008, "Wrong alignment on bpCodeLib_StringEquation");
static_assert(sizeof(bpCodeLib_StringEquation) == 0x000018, "Wrong size on bpCodeLib_StringEquation");
static_assert(offsetof(bpCodeLib_StringEquation, Equation) == 0x000000, "Member 'bpCodeLib_StringEquation::Equation' has a wrong offset!");
static_assert(offsetof(bpCodeLib_StringEquation, Answer) == 0x000010, "Member 'bpCodeLib_StringEquation::Answer' has a wrong offset!");

// Function VotV.bpCodeLib.tetrahedronVolume
// 0x0034 (0x0034 - 0x0000)
struct bpCodeLib_TetrahedronVolume final
{
public:
	struct FVector                                VecA;                                              // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VecB;                                              // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VecC;                                              // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VecD;                                              // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_TetrahedronVolume) == 0x000004, "Wrong alignment on bpCodeLib_TetrahedronVolume");
static_assert(sizeof(bpCodeLib_TetrahedronVolume) == 0x000034, "Wrong size on bpCodeLib_TetrahedronVolume");
static_assert(offsetof(bpCodeLib_TetrahedronVolume, VecA) == 0x000000, "Member 'bpCodeLib_TetrahedronVolume::VecA' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TetrahedronVolume, VecB) == 0x00000C, "Member 'bpCodeLib_TetrahedronVolume::VecB' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TetrahedronVolume, VecC) == 0x000018, "Member 'bpCodeLib_TetrahedronVolume::VecC' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TetrahedronVolume, VecD) == 0x000024, "Member 'bpCodeLib_TetrahedronVolume::VecD' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TetrahedronVolume, ReturnValue) == 0x000030, "Member 'bpCodeLib_TetrahedronVolume::ReturnValue' has a wrong offset!");

// Function VotV.bpCodeLib.translateAriral
// 0x0020 (0x0020 - 0x0000)
struct bpCodeLib_TranslateAriral final
{
public:
	class FString                                 In;                                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Out;                                               // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_TranslateAriral) == 0x000008, "Wrong alignment on bpCodeLib_TranslateAriral");
static_assert(sizeof(bpCodeLib_TranslateAriral) == 0x000020, "Wrong size on bpCodeLib_TranslateAriral");
static_assert(offsetof(bpCodeLib_TranslateAriral, In) == 0x000000, "Member 'bpCodeLib_TranslateAriral::In' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TranslateAriral, Out) == 0x000010, "Member 'bpCodeLib_TranslateAriral::Out' has a wrong offset!");

// Function VotV.bpCodeLib.triangleNormal
// 0x0030 (0x0030 - 0x0000)
struct bpCodeLib_TriangleNormal final
{
public:
	struct FVector                                Point1;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point2;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point3;                                            // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_TriangleNormal) == 0x000004, "Wrong alignment on bpCodeLib_TriangleNormal");
static_assert(sizeof(bpCodeLib_TriangleNormal) == 0x000030, "Wrong size on bpCodeLib_TriangleNormal");
static_assert(offsetof(bpCodeLib_TriangleNormal, Point1) == 0x000000, "Member 'bpCodeLib_TriangleNormal::Point1' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TriangleNormal, Point2) == 0x00000C, "Member 'bpCodeLib_TriangleNormal::Point2' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TriangleNormal, Point3) == 0x000018, "Member 'bpCodeLib_TriangleNormal::Point3' has a wrong offset!");
static_assert(offsetof(bpCodeLib_TriangleNormal, Normal) == 0x000024, "Member 'bpCodeLib_TriangleNormal::Normal' has a wrong offset!");

// Function VotV.bpCodeLib.vecBoundBox
// 0x0050 (0x0050 - 0x0000)
struct bpCodeLib_VecBoundBox final
{
public:
	TArray<struct FVector>                        Vecs;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Box;                                               // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0034(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                boundingCenter;                                    // 0x0040(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C6[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_VecBoundBox) == 0x000008, "Wrong alignment on bpCodeLib_VecBoundBox");
static_assert(sizeof(bpCodeLib_VecBoundBox) == 0x000050, "Wrong size on bpCodeLib_VecBoundBox");
static_assert(offsetof(bpCodeLib_VecBoundBox, Vecs) == 0x000000, "Member 'bpCodeLib_VecBoundBox::Vecs' has a wrong offset!");
static_assert(offsetof(bpCodeLib_VecBoundBox, Min) == 0x000010, "Member 'bpCodeLib_VecBoundBox::Min' has a wrong offset!");
static_assert(offsetof(bpCodeLib_VecBoundBox, Max) == 0x00001C, "Member 'bpCodeLib_VecBoundBox::Max' has a wrong offset!");
static_assert(offsetof(bpCodeLib_VecBoundBox, Box) == 0x000028, "Member 'bpCodeLib_VecBoundBox::Box' has a wrong offset!");
static_assert(offsetof(bpCodeLib_VecBoundBox, Origin) == 0x000034, "Member 'bpCodeLib_VecBoundBox::Origin' has a wrong offset!");
static_assert(offsetof(bpCodeLib_VecBoundBox, boundingCenter) == 0x000040, "Member 'bpCodeLib_VecBoundBox::boundingCenter' has a wrong offset!");

// Function VotV.bpCodeLib.weightedRandomV2
// 0x0018 (0x0018 - 0x0000)
struct bpCodeLib_WeightedRandomV2 final
{
public:
	TArray<float>                                 Weights;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C7[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(bpCodeLib_WeightedRandomV2) == 0x000008, "Wrong alignment on bpCodeLib_WeightedRandomV2");
static_assert(sizeof(bpCodeLib_WeightedRandomV2) == 0x000018, "Wrong size on bpCodeLib_WeightedRandomV2");
static_assert(offsetof(bpCodeLib_WeightedRandomV2, Weights) == 0x000000, "Member 'bpCodeLib_WeightedRandomV2::Weights' has a wrong offset!");
static_assert(offsetof(bpCodeLib_WeightedRandomV2, Param_Index) == 0x000010, "Member 'bpCodeLib_WeightedRandomV2::Param_Index' has a wrong offset!");

// Function VotV.bpCodeLib.weightedRandomV2_exponent
// 0x0018 (0x0018 - 0x0000)
struct bpCodeLib_WeightedRandomV2_exponent final
{
public:
	TArray<float>                                 Weights;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_WeightedRandomV2_exponent) == 0x000008, "Wrong alignment on bpCodeLib_WeightedRandomV2_exponent");
static_assert(sizeof(bpCodeLib_WeightedRandomV2_exponent) == 0x000018, "Wrong size on bpCodeLib_WeightedRandomV2_exponent");
static_assert(offsetof(bpCodeLib_WeightedRandomV2_exponent, Weights) == 0x000000, "Member 'bpCodeLib_WeightedRandomV2_exponent::Weights' has a wrong offset!");
static_assert(offsetof(bpCodeLib_WeightedRandomV2_exponent, Exponent) == 0x000010, "Member 'bpCodeLib_WeightedRandomV2_exponent::Exponent' has a wrong offset!");
static_assert(offsetof(bpCodeLib_WeightedRandomV2_exponent, Param_Index) == 0x000014, "Member 'bpCodeLib_WeightedRandomV2_exponent::Param_Index' has a wrong offset!");

// Function VotV.bpCodeLib.weightedRandomV2_lerp
// 0x0018 (0x0018 - 0x0000)
struct bpCodeLib_WeightedRandomV2_lerp final
{
public:
	TArray<float>                                 Weights;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Ulerp;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_WeightedRandomV2_lerp) == 0x000008, "Wrong alignment on bpCodeLib_WeightedRandomV2_lerp");
static_assert(sizeof(bpCodeLib_WeightedRandomV2_lerp) == 0x000018, "Wrong size on bpCodeLib_WeightedRandomV2_lerp");
static_assert(offsetof(bpCodeLib_WeightedRandomV2_lerp, Weights) == 0x000000, "Member 'bpCodeLib_WeightedRandomV2_lerp::Weights' has a wrong offset!");
static_assert(offsetof(bpCodeLib_WeightedRandomV2_lerp, Ulerp) == 0x000010, "Member 'bpCodeLib_WeightedRandomV2_lerp::Ulerp' has a wrong offset!");
static_assert(offsetof(bpCodeLib_WeightedRandomV2_lerp, Param_Index) == 0x000014, "Member 'bpCodeLib_WeightedRandomV2_lerp::Param_Index' has a wrong offset!");

// Function VotV.bpCodeLib.GetAllAttachedActors
// 0x0018 (0x0018 - 0x0000)
struct bpCodeLib_GetAllAttachedActors final
{
public:
	class AActor*                                 ParentActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(bpCodeLib_GetAllAttachedActors) == 0x000008, "Wrong alignment on bpCodeLib_GetAllAttachedActors");
static_assert(sizeof(bpCodeLib_GetAllAttachedActors) == 0x000018, "Wrong size on bpCodeLib_GetAllAttachedActors");
static_assert(offsetof(bpCodeLib_GetAllAttachedActors, ParentActor) == 0x000000, "Member 'bpCodeLib_GetAllAttachedActors::ParentActor' has a wrong offset!");
static_assert(offsetof(bpCodeLib_GetAllAttachedActors, ReturnValue) == 0x000008, "Member 'bpCodeLib_GetAllAttachedActors::ReturnValue' has a wrong offset!");

// Function VotV.cppInterface.impactDamageCPP
// 0x00A8 (0x00A8 - 0x0000)
struct CppInterface_ImpactDamageCPP final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0004(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C8[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Impact;                                            // 0x0098(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C9[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CppInterface_ImpactDamageCPP) == 0x000008, "Wrong alignment on CppInterface_ImpactDamageCPP");
static_assert(sizeof(CppInterface_ImpactDamageCPP) == 0x0000A8, "Wrong size on CppInterface_ImpactDamageCPP");
static_assert(offsetof(CppInterface_ImpactDamageCPP, Damage) == 0x000000, "Member 'CppInterface_ImpactDamageCPP::Damage' has a wrong offset!");
static_assert(offsetof(CppInterface_ImpactDamageCPP, Hit) == 0x000004, "Member 'CppInterface_ImpactDamageCPP::Hit' has a wrong offset!");
static_assert(offsetof(CppInterface_ImpactDamageCPP, Actor) == 0x000090, "Member 'CppInterface_ImpactDamageCPP::Actor' has a wrong offset!");
static_assert(offsetof(CppInterface_ImpactDamageCPP, Impact) == 0x000098, "Member 'CppInterface_ImpactDamageCPP::Impact' has a wrong offset!");

// Function VotV.cppInterface.impactSquishCPP
// 0x0008 (0x0008 - 0x0000)
struct CppInterface_ImpactSquishCPP final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CppInterface_ImpactSquishCPP) == 0x000008, "Wrong alignment on CppInterface_ImpactSquishCPP");
static_assert(sizeof(CppInterface_ImpactSquishCPP) == 0x000008, "Wrong size on CppInterface_ImpactSquishCPP");
static_assert(offsetof(CppInterface_ImpactSquishCPP, Component) == 0x000000, "Member 'CppInterface_ImpactSquishCPP::Component' has a wrong offset!");

}

